# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""AES specific SCryptoAlgorithm."""
from typing import Dict
from typing import Literal
import numpy as np

from scaaml.capture.aes.acqktp import AcqKeyTextPatternScaaml as ktp_scaaml
from scaaml.io import resume_kti


class SCryptoAlgorithm:
    """attack points and maybe some basic information about it (e.g. key length, etc.)"""
    def __init__(self,
                 firmware_sha256: str,
                 crypto_implementation,
                 purpose: Literal['train', 'test', 'holdout'],
                 implementation: str = "MBEDTLS",
                 algorithm: str = "simpleserial-aes",
                 keys: int = 3072,
                 plaintexts: int = 256,
                 repetitions: int = 1,
                 examples_per_shard: int = 64,
                 full_kt_filename: str = 'key_text_pairs.txt',
                 full_progress_filename: str = 'progress_pairs.txt') -> None:
        """Generates a set of key-text pairs and saves those. Does not overwrite
        existing files.

        Args:
          firmware_sha256: SHA256 hash of the binary used on the chip.
          crypto_implementation: The class that provides attack points info and
            attack points values (for instance scaaml.aes_forward.AESSBOX).
          purpose: Type of the dataset. Used in scaaml.io.Dataset.
          implementation: Name of the implementation that was used.
          algorithm: Algorithm name.
          keys: Number of different keys that are used.
          plaintexts: Number of different plaintexts used with each key.
          repetitions: Number of captures with a concrete (key, plaintext) pair.
          examples_per_shard: Size of a single part (for ML training purposes).
          kt_filename: Filename to save key, text pairs (using resume_kti).
          progress_filename: Filename to save progress (using resume_kti).
          full_kt_filename: The file to save key-text pairs into. This should
            be in the same directory as the whole dataset.
          full_progress_filename: The file to save progress into. This should
            be in the same directory as the whole dataset.
        """
        # TODO(karelkral): Automatically check scaaml.io.utils.sha256sum(firmware_file).
        # When changing the following assert update also
        # SCryptoAlgorithm._dataset
        assert purpose in ['train', 'test', 'holdout']
        self._firmware_sha256 = firmware_sha256
        self._crypto_implementation = crypto_implementation
        self._implementation = implementation
        self._algorithm = algorithm
        self._keys = keys
        self._plaintexts = plaintexts
        self._repetitions = repetitions
        self._examples_per_shard = examples_per_shard
        self._purpose = purpose
        self._kt_filename = full_kt_filename
        self._progress_filename = full_progress_filename
        self._full_kt_filename = full_kt_filename
        self._full_progress_filename = full_progress_filename

        # Generate ans save key-text pairs.
        ktp = self._get_new_ktp()
        # Turn what gets generated by ktp into two arrays and save it.
        keys = []
        texts = []
        while True:
            try:
                # AcqKeyTextPatternScaaml.new_pair returns (key, text)
                kt_pair = ktp.new_pair()
                keys.append(list(kt_pair[0]))
                texts.append(list(kt_pair[1]))
            except StopIteration:
                break
        keys = np.array(keys, dtype=np.uint8)
        texts = np.array(texts, dtype=np.uint8)
        # Does not overwrite existing keys-texts file.
        self._kti = resume_kti.create_resume_kti(
            keys=keys,
            texts=texts,
            shard_length=self._examples_per_shard,
            kt_filename=self._full_kt_filename,
            progress_filename=self._full_progress_filename)
        # Set in get_stabilization_kti.
        self._stabilization_ktp = None

    def attack_points_info(self):
        """Returns the attack points info."""
        return self._crypto_implementation.ATTACK_POINTS_INFO

    def attack_points(self, **kwargs: bytearray) -> Dict[str, bytearray]:
        """Returns the attack points for specific parameters (such as the
        key-text pair).

        Typical usage example:
          aps = crypto_algorithm.attack_points(key=key, plaintext=plaintext)
        """
        c_i = self._crypto_implementation
        aps = {}
        for attack_point_name in c_i.ATTACK_POINTS_INFO:
            aps[attack_point_name] = c_i.get_attack_point(
                attack_point_name, **kwargs)
        return aps

    def _get_new_ktp(self):
        ktp = ktp_scaaml()
        ktp.dataset = self._dataset
        ktp.plaintext_per_key = self._plaintexts
        ktp.repetitions = self._repetitions
        ktp.nb_keys = self._keys
        ktp.init(0)
        return ktp

    def get_stabilization_kti(self):
        """Key-text iterator for stabilizing the capture. This is different
        from the real kti.
        """
        if self._stabilization_ktp is not None:
            return self._stabilization_ktp

        class StabilizationIterator:
            """Iterates through key-plaintext pairs used for stabilizing the
            capture."""
            def __init__(self, ktp):
                self._ktp = ktp

            def __iter__(self):
                return self

            def __next__(self):
                # AcqKeyTextPatternScaaml.new_pair raises StopIteration itself.
                kt_pair = self._ktp.new_pair()
                # Allow the same iteration as using resume_kti.
                return list(kt_pair[0]), list(kt_pair[1])

        self._stabilization_ktp = StabilizationIterator(self._get_new_ktp())
        return self._stabilization_ktp

    @property
    def kti(self):
        """Key-plaintext iterator."""
        return self._kti

    @property
    def examples_per_shard(self):
        """How many traces are captured in a shard."""
        return self._examples_per_shard

    @property
    def keys(self):
        """Number of different keys generated."""
        return self._keys

    @property
    def plaintexts(self):
        """Number of different plaintexts used with a single key."""
        return self._plaintexts

    @property
    def repetitions(self):
        """Number of times each (key,text) pair is repeated."""
        return self._repetitions

    @property
    def key_len(self):
        """Length of the key in bytes."""
        return self._crypto_implementation.KEY_LENGTH

    @property
    def plaintext_len(self):
        """Length of the plaintext in bytes."""
        return self._crypto_implementation.PLAINTEXT_LENGTH

    @property
    def firmware_sha256(self):
        """SHA256 hash of the firmware."""
        return self._firmware_sha256

    @property
    def implementation(self):
        """The implementation used."""
        return self._implementation

    @property
    def algorithm(self):
        """The algorithm used."""
        return self._algorithm

    @property
    def purpose(self):
        """The parameter split in scaaml.io.Database.new_shard, in
        ['train', 'test', 'holdout']"""
        return self._purpose

    @property
    def _dataset(self) -> Literal['Training', 'Validation']:
        """Return the dataset type used in ktp_scaaml."""
        # purpose is used in scaaml.io.Dataset
        purpose_to_dataset = {
            'train': 'Training',
            'test': 'Training',
            'holdout': 'Validation',
        }
        return purpose_to_dataset[self._purpose]
